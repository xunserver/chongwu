{
  "id": "snapshot_1769601280151_3ji54wg8s",
  "approvalId": "approval_1769601280146_6tt3h2g68",
  "approvalTitle": "修复登录页邮箱验证 Bug - Design 阶段",
  "version": 1,
  "timestamp": "2026-01-28T11:54:40.151Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\n本设计文档描述如何修复登录页邮箱验证功能的 bug。当前 bug 的根本原因是验证器返回值处理错误：`validators.email()` 返回 `string | null`（null 表示验证通过），但代码错误地使用了 `!validators.email(value)`，导致有效邮箱返回 true（因为 `!null === true`），从而触发错误提示。\n\n修复方案非常简单直接：正确处理验证器的返回值类型，将逻辑从 `if (!validators.email(value))` 改为 `const error = validators.email(value); if (error) return error`。\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\n本项目遵循以下技术标准：\n\n- **Vue 3 Composition API**: 使用 `<script setup>` 语法和响应式工具\n- **TypeScript 类型安全**: 所有函数都有明确的类型签名\n- **TanStack Form**: 使用声明式表单验证\n- **模块化验证器**: 验证逻辑集中在 `validators.ts` 中\n\n本修复完全符合现有技术标准，不引入新的依赖或模式。\n\n### Project Structure (structure.md)\n\n项目采用 features-based 结构：\n\n```\nsrc/features/auth/\n├── components/      # UI 组件\n├── hooks/          # 业务逻辑 hooks\n├── utils/          # 工具函数（包括验证器）\n└── views/          # 视图页面\n```\n\n修复仅涉及 `src/features/auth/views/LoginView.vue`，保持模块边界清晰。\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n- **validators.ts**: 验证器模块本身无需修改，API 设计（返回 `string | null`）是正确的\n- **LoginView.vue**: 仅修复验证逻辑，保持组件结构不变\n- **AuthForm.vue**: 表单容器组件，无需修改\n- **Input.vue**: shadcn-vue 输入组件，无需修改\n\n### Integration Points\n\n- **TanStack Form**: 使用 `form.Field` 的 `validators` API\n- **validators.email()**: 保持现有的 API 契约不变\n- **错误显示逻辑**: 保持现有的 `field.state.meta.errors[0]` 显示机制\n\n## Architecture\n\n### Bug 根本原因分析\n\n```mermaid\ngraph TD\n    A[用户输入邮箱] --> B[TanStack Form 触发 onChange]\n    B --> C{调用 validators.email}\n    C -->|有效邮箱| D[返回 null]\n    C -->|无效邮箱| E[返回错误字符串]\n    D --> F[当前代码: !null === true]\n    F --> G[错误显示'邮箱格式不正确']\n    E --> F\n    G --> H[Bug: 有效邮箱被拒绝]\n\n    style G fill:#ff6b6b\n    style H fill:#ff6b6b\n```\n\n### 修复方案架构\n\n```mermaid\ngraph TD\n    A[用户输入邮箱] --> B[TanStack Form 触发 onChange]\n    B --> C{调用 validators.email}\n    C -->|有效邮箱| D[返回 null]\n    C -->|无效邮箱| E[返回错误字符串]\n    D --> F[修复后: const error = validators.email value]\n    F --> G{error 是否为 truthy?}\n    G -->|null| H[验证通过，无错误]\n    G -->|字符串| I[返回错误消息]\n    E --> I\n\n    style H fill:#51cf66\n    style I fill:#ffd43b\n```\n\n### Modular Design Principles\n\n- **Single File Responsibility**: `LoginView.vue` 负责视图层验证逻辑，`validators.ts` 负责核心验证规则\n- **Component Isolation**: 修复不涉及其他组件\n- **Service Layer Separation**: 保持服务层（authService）不变\n- **Utility Modularity**: `validators.email()` 作为独立工具函数，API 保持不变\n\n## Components and Interfaces\n\n### LoginView.vue（修改）\n\n- **Purpose:** 用户登录页面视图\n- **修改内容:** 邮箱字段验证器的 `onChange` 回调逻辑\n- **修改前:**\n  ```typescript\n  :validators=\"{\n    onChange: ({ value }) => {\n      if (!value) return '邮箱不能为空'\n      if (!validators.email(value)) return '邮箱格式不正确'  // ❌ Bug\n    },\n  }\"\n  ```\n- **修改后:**\n  ```typescript\n  :validators=\"{\n    onChange: ({ value }) => {\n      if (!value) return '邮箱不能为空'\n      const emailError = validators.email(value)  // ✅ 正确\n      if (emailError) return emailError\n    },\n  }\"\n  ```\n- **Dependencies:**\n  - `@tanstack/vue-form`: useForm\n  - `@/features/auth/utils/validators`: validators.email\n  - Vue Router: useRouter\n- **Reuses:** 保持现有组件结构、hooks、表单字段\n\n### validators.ts（无需修改）\n\n- **Purpose:** 提供表单验证函数\n- **API:**\n  ```typescript\n  function validateEmail(email: string): string | null\n  // 返回 null 表示验证通过，返回字符串表示错误消息\n  ```\n- **Why No Change:** API 设计本身是正确的，返回 `string | null` 是合理的模式\n\n## Data Models\n\n无需新的数据模型。修复仅涉及验证逻辑，不改变数据流。\n\n### 验证器返回值类型\n\n```typescript\ntype ValidationResult = string | null\n// null = 验证通过\n// string = 错误消息\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **空邮箱输入**\n   - **Handling:** 返回 \"邮箱不能为空\"\n   - **User Impact:** 显示红色错误提示在邮箱输入框下方\n\n2. **无效邮箱格式**（如 test、test@、@example.com）\n   - **Handling:** `validators.email()` 返回 \"请输入有效的邮箱地址\"\n   - **User Impact:** 显示红色错误提示在邮箱输入框下方\n\n3. **有效邮箱格式**（如 test@example.com）\n   - **Handling:** `validators.email()` 返回 `null`，验证器返回 `undefined`（无错误）\n   - **User Impact:** 不显示错误提示，用户可以继续填写或提交表单\n\n4. **邮箱包含前后空格**（如 \" test@example.com \"）\n   - **Handling:** `validators.email()` 内部自动 trim，验证实际邮箱内容\n   - **User Impact:** 空格不影响验证结果\n\n## Testing Strategy\n\n### Unit Testing\n\n**文件:** `src/features/auth/views/LoginView.spec.ts`（新建）\n\n测试用例：\n1. 有效邮箱不应显示错误（如 test@example.com）\n2. 无效邮箱应显示错误（如 test、test@、@example.com）\n3. 空邮箱应显示\"邮箱不能为空\"\n4. 邮箱前后空格应被正确处理\n\n**当前状态:** 项目已有 Vitest 配置和测试脚本\n\n### Integration Testing\n\n**测试流程:**\n1. 启动开发服务器\n2. 访问登录页 `/auth/login`\n3. 输入有效邮箱（test@example.com）→ 应无错误提示\n4. 输入无效邮箱（test）→ 应显示\"请输入有效的邮箱地址\"\n5. 清空邮箱 → 应显示\"邮箱不能为空\"\n6. 输入有效邮箱和有效密码 → 应能成功提交表单\n\n### 手动验证步骤\n\n1. 运行 `pnpm dev`\n2. 打开浏览器访问 `http://localhost:5173/auth/login`\n3. 测试各种邮箱输入：\n   - `test@example.com` → ✅ 无错误\n   - `test` → ❌ \"请输入有效的邮箱地址\"\n   - `@example.com` → ❌ \"请输入有效的邮箱地址\"\n   - `test@` → ❌ \"请输入有效的邮箱地址\"\n   - ``（空）→ ❌ \"邮箱不能为空\"\n   - ` test@example.com ` → ✅ 无错误（自动 trim）\n\n## Implementation Notes\n\n### 修改文件清单\n\n1. **src/features/auth/views/LoginView.vue**\n   - 第 80-85 行：邮箱字段验证器逻辑\n   - 修改：将 `if (!validators.email(value))` 改为 `const emailError = validators.email(value); if (emailError)`\n\n2. **新建测试文件（可选但推荐）**\n   - `src/features/auth/views/LoginView.spec.ts`\n   - 测试邮箱验证的各种场景\n\n### 不需要修改的文件\n\n- `src/features/auth/utils/validators.ts` - 验证器本身正确，无需修改\n- `src/features/auth/views/RegisterView.vue` - 如有类似问题需要一并检查修复\n- `src/features/auth/views/ForgotPasswordView.vue` - 如有类似问题需要一并检查修复\n\n### 向后兼容性\n\n✅ 完全向后兼容\n- 不改变任何 API 契约\n- 不改变 UI 结构\n- 仅修复逻辑错误\n- 不影响其他组件\n\n### 性能影响\n\n✅ 无性能影响\n- 修复前后都是调用一次 `validators.email()`\n- 不引入额外的计算或重渲染\n",
  "fileStats": {
    "size": 7720,
    "lines": 235,
    "lastModified": "2026-01-28T11:54:38.274Z"
  },
  "comments": []
}